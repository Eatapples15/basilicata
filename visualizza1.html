<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizza Mappa Criticità per Rischio</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            padding: 20px;
        }

        #leaflet-map {
            flex: 2;
            min-width: 300px;
            height: 500px;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        #info-container {
            flex: 1;
            min-width: 200px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            background-color: #f9f9f9;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        select {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
            font-size: 16px;
        }

        #current-risk-legend {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px dashed #ccc;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .legend-color-box {
            width: 20px;
            height: 20px;
            border: 1px solid #777;
            margin-right: 8px;
            flex-shrink: 0;
        }

        #last-updated {
            font-style: italic;
            color: #777;
        }

        #save-pdf-button {
            padding: 10px 15px;
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 20px;
            transition: background-color 0.3s ease;
        }

        #save-pdf-button:hover {
            background-color: #c82333;
        }

        #region-logo {
            width: 100%;
            max-width: 200px;
            height: auto;
            margin-top: auto;
            align-self: center;
            padding-top: 20px;
        }

        /* Leaflet popup styles */
        .leaflet-popup-content-wrapper {
            background-color: white;
            color: #333;
            border-radius: 5px;
            padding: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .leaflet-popup-content {
            margin: 0;
        }

        .leaflet-popup-tip-container {
            width: 20px;
            height: 10px;
        }

        .leaflet-popup-tip {
            background: white;
            border: 1px solid #aaa;
            border-top-color: transparent;
            border-left-color: transparent;
        }
    </style>
</head>

<body>

    <div id="leaflet-map"></div>

    <div id="info-container">
        <div class="form-group">
            <label for="risk-selector">Seleziona Rischio:</label>
            <select id="risk-selector">
                </select>
        </div>

        <div id="current-risk-legend">
            <h4>Legenda Rischio Corrente:</h4>
            </div>

        <h3>Ultimo Aggiornamento</h3>
        <p id="last-updated"></p>
        <button id="save-pdf-button">Scarica come PDF</button>

        <img src="Logo regione.png" alt="Logo Regione Basilicata" id="region-logo">
    </div>

    <script src="https://www.gstatic.com/firebasejs/10.11.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.11.0/firebase-database-compat.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://unpkg.com/leaflet-image@latest/leaflet-image.js"></script>

    <script>
        // Your web app's Firebase configuration (IDENTICO A index.html)
        const firebaseConfig = {
            apiKey: "AIzaSyD1ABRI99tMtvFbbvjqyjbLImfgNMdRR28",
            authDomain: "bollettinoregionale.firebaseapp.com",
            projectId: "bollettinoregionale",
            databaseURL: "https://bollettinoregionale-default-rtdb.europe-west1.firebasedatabase.app/",
            storageBucket: "bollettinoregionale.appspot.com",
            messagingSenderId: "765538370497",
            appId: "1:765538370497:web:9c4f569754c0df01cc2540",
            // measurementId: "G-0BCQ0VRNXF" // measurementId è opzionale
        };

        // Initialize Firebase
        const app = firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        const leafletMap = L.map('leaflet-map').setView([40.6393, 15.8054], 8);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(leafletMap);

        const lastUpdatedElement = document.getElementById('last-updated');
        const savePdfButton = document.getElementById('save-pdf-button');
        const riskSelector = document.getElementById('risk-selector');
        const currentRiskLegend = document.getElementById('current-risk-legend');

        let criticitàMap = {}; // Maps normalized comune name to its 'Base' (e.g., "potenza" -> "B")
        let riskColorsData = {}; // Stores colors for each base, per risk type (e.g., {'idrogeologico_temporali': {'A1': 'red', ...}})
        let geoJsonLayer = null; // Stores the Leaflet GeoJSON layer

        // Define the mapping of common names for display
        const riskDisplayName = {
            'idrogeologico_temporali': 'Idrogeologico (Temporali)',
            'idrogeologico': 'Idrogeologico',
            'idraulico': 'Idraulico',
            'incendio': 'Incendio'
        };

        // Normalizzazione dei nomi dei comuni
        function normalizeComuneName(nome) {
            if (!nome) return "";
            return nome.toLowerCase().trim().replace(/\s+/g, ' ').normalize("NFD").replace(/[\u0300-\u036f]/g, "");
        }

        // Funzione per ottenere il codice esadecimale da un nome di colore
        function getHexColor(colorName) {
            switch (colorName) {
                case 'green': return '#008000';
                case 'yellow': return '#FFFF00';
                case 'orange': return '#FFA500';
                case 'red': return '#FF0000';
                default: return '#ccc'; // Default grey for missing colors
            }
        }

        // Configuration of criticality bases and their municipalities
        const configurazioneCriticità = {
            'A1': ["Montemilone", "Atella", "Palazzo San Gervasio", "Pescopagano", "Rapolla", "Rapone", "Rionero in Vulture", "Ripacandida", "Ruvo del Monte", "San Fele", "Filiano", "Forenza", "Lavello", "Barile", "Maschito", "Melfi", "Venosa", "Ginestra"],
            'A2': ["Muro Lucano", "Balvano", "Baragiano", "Bella", "Brienza", "Castelgrande", "Picerno", "Ruoti", "Sant'Angelo Le Fratte", "Sasso di Castalda", "Satriano di Lucania", "Savoia di Lucania", "Tito", "Vietri di Potenza"],
            'B': ["Abriola", "Accettura", "Acerenza", "Albano di Lucania", "Anzi", "Avigliano", "Banzi", "Brindisi Montagna", "Calciano", "Calvello", "Campomaggiore", "Cancellara", "Castelmezzano", "Ferrandina", "Filiano", "Forenza", "Garaguso", "Genzano di Lucania", "Grassano", "Grottole", "Irsina", "Laurenzana", "Miglionico", "Oliveto Lucano", "Oppido Lucano", "Pietragalla", "Pietrapertosa", "Pignola", "Pomarico", "Potenza", "Salandra", "San Chirico Nuovo", "San Mauro Forte", "Tito", "Tolve", "Tricarico", "Trivigno", "Vaglio Basilicata", "Matera"],
            'C': ["Montemurro", "Aliano", "Armento", "Calvera", "Carbone", "Castronuovo di Sant'Andrea", "Cersosimo", "Chiaromonte", "Cirigliano", "Colobraro", "Corleto Perticara", "Episcopia", "Fardella", "Francavilla in Sinni", "Gallicchio", "Gorgoglione", "Grumento Nova", "Guardia Perticara", "Marsico Nuovo", "Marsicovetere", "Missanello", "Moliterno", "Noepoli", "Paterno", "Roccanova", "San Chirico Raparo", "San Costantino Albanese", "San Giorgio Lucano", "San Martino d'Agri", "San Paolo Albanese", "San Severino Lucano", "Sant'Arcangelo", "Sarconi", "Senise", "Spinoso", "Stigliano", "Teana", "Terranova di Pollino", "Tramutola", "Tursi", "Valsinni", "Viggiano"],
            'D': ["Nemoli", "Castelluccio Inferiore", "Castelluccio Superiore", "Castelsaraceno", "Lagonegro", "Latronico", "Lauria", "Maratea", "Rivello", "Rotonda", "Trecchina", "Viggianello"],
            'E1': ["Nova Siri", "Policoro", "Rotondella", "Scanzano Jonico", "Tursi", "Montalbano Jonico", "Craco"],
            'E2': ["Montescaglioso", "Bernalda", "Pisticci", "Pomarico", "Ferrandina"]
        };

        // Build the criticality map (normalized comune name to base) once
        for (const base in configurazioneCriticità) {
            const comuni = configurazioneCriticità[base];
            comuni.forEach(comune => {
                const normalizedComune = normalizeComuneName(comune);
                criticitàMap[normalizedComune] = base;
            });
        }

        // Function to get the base for a given normalized comune name
        function getBaseForComune(comuneNome) {
            return criticitàMap[comuneNome];
        }

        // Main function to fetch data, populate selector, and display map
        function initializeMap() {
            // Fetch risk-specific colors from Firebase
            database.ref('colori').once('value', snapshot => {
                if (snapshot.exists()) {
                    const datiColori = snapshot.val();
                    riskColorsData = datiColori.rischi || {}; // Get the 'rischi' node
                    const timestamp = new Date(datiColori.dataCreazione);
                    const formattedDate = timestamp.toLocaleString();
                    lastUpdatedElement.textContent = `Aggiornato il: ${formattedDate}`;

                    // Populate the risk selector dropdown
                    const riskTypes = Object.keys(riskColorsData);
                    riskSelector.innerHTML = ''; // Clear existing options
                    riskTypes.forEach(riskKey => {
                        const option = document.createElement('option');
                        option.value = riskKey;
                        option.textContent = riskDisplayName[riskKey] || riskKey; // Use display name if available
                        riskSelector.appendChild(option);
                    });

                    // Set initial map display and legend
                    updateMapAndLegend();

                    // Add event listener for selector change
                    riskSelector.addEventListener('change', updateMapAndLegend);

                } else {
                    lastUpdatedElement.textContent = 'Nessun dato colore disponibile.';
                }
            }, error => {
                console.error("Errore nel recupero dei colori:", error);
                lastUpdatedElement.textContent = 'Errore nel caricamento dei colori.';
            });
        }

        // Function to update the map and legend based on selected risk
        function updateMapAndLegend() {
            const selectedRisk = riskSelector.value;
            const currentRiskBaseColors = riskColorsData[selectedRisk] || {}; // Colors for the selected risk

            if (geoJsonLayer) {
                leafletMap.removeLayer(geoJsonLayer);
            }

            // Load GeoJSON data again (or use the one already loaded if it's in a global var)
            fetch('limits_R_17_municipalities.geojson')
                .then(response => response.json())
                .then(geojsonData => {
                    // Pre-process geojsonData to add normalized names (if not already done)
                    geojsonData.features.forEach(feature => {
                        if (feature.properties && feature.properties.name && !feature.properties.normalizedName) {
                            feature.properties.normalizedName = normalizeComuneName(feature.properties.name);
                        }
                    });

                    geoJsonLayer = L.geoJSON(geojsonData, {
                        style: function (feature) {
                            return styleComune(feature, currentRiskBaseColors);
                        },
                        onEachFeature: onEachFeature
                    }).addTo(leafletMap);

                    updateLegend(currentRiskBaseColors); // Update the legend
                })
                .catch(error => console.error("Errore nel caricamento del GeoJSON:", error));
        }

        // Function to determine municipality style
        function styleComune(feature, currentRiskBaseColors) {
            const normalizedComuneNome = feature.properties.normalizedName;
            const base = getBaseForComune(normalizedComuneNome); // Get the geographical base (A1, B, etc.)

            let fillColor = '#ccc'; // Default color for municipalities not mapped or without color
            let fillOpacity = 0.7;

            if (base && currentRiskBaseColors[base]) {
                fillColor = getHexColor(currentRiskBaseColors[base]);
            }

            return {
                fillColor: fillColor,
                weight: 1,
                opacity: 1,
                color: '#333',
                fillOpacity: fillOpacity
            };
        }

        // Function to create popup content
        function onEachFeature(feature, layer) {
            if (feature.properties && feature.properties.name) {
                const normalizedComuneNome = feature.properties.normalizedName;
                const base = getBaseForComune(normalizedComuneNome) || 'Non assegnata';
                const selectedRisk = riskSelector.value;
                const riskColor = riskColorsData[selectedRisk] ? (riskColorsData[selectedRisk][base] || 'N/A') : 'N/A';

                layer.bindPopup(`
                    <b>Comune: ${feature.properties.name}</b><br>
                    Base di Appartenenza: ${base}<br>
                    Rischio "${riskDisplayName[selectedRisk] || selectedRisk}": ${riskColor}
                `);
            }
        }

        // Function to update the dynamic legend
        function updateLegend(colorsForSelectedRisk) {
            currentRiskLegend.innerHTML = '<h4>Legenda Rischio Corrente:</h4>';
            
            // Sort bases for consistent legend order (e.g., A1, A2, B, C...)
            const sortedBases = Object.keys(configurazioneCriticità).sort((a, b) => {
                // Simple sort for A1, A2, B, C, D, E1, E2
                const order = ['A1', 'A2', 'B', 'C', 'D', 'E1', 'E2'];
                return order.indexOf(a) - order.indexOf(b);
            });

            sortedBases.forEach(base => {
                const colorName = colorsForSelectedRisk[base];
                if (colorName) { // Only show bases that have a color defined for the current risk
                    const hexColor = getHexColor(colorName);

                    const legendItem = document.createElement('div');
                    legendItem.className = 'legend-item';

                    const colorBox = document.createElement('div');
                    colorBox.className = 'legend-color-box';
                    colorBox.style.backgroundColor = hexColor;

                    const text = document.createElement('span');
                    text.textContent = `Base ${base}: ${colorName.charAt(0).toUpperCase() + colorName.slice(1)}`;

                    legendItem.appendChild(colorBox);
                    legendItem.appendChild(text);
                    currentRiskLegend.appendChild(legendItem);
                }
            });

            // Add a default entry for uncolored areas if desired
            const defaultItem = document.createElement('div');
            defaultItem.className = 'legend-item';
            const defaultColorBox = document.createElement('div');
            defaultColorBox.className = 'legend-color-box';
            defaultColorBox.style.backgroundColor = '#ccc';
            const defaultText = document.createElement('span');
            defaultText.textContent = `Base Non Mappata / Nessun Rischio`;
            defaultItem.appendChild(defaultColorBox);
            defaultItem.appendChild(defaultText);
            currentRiskLegend.appendChild(defaultItem);
        }

        // PDF Generation Logic
        savePdfButton.addEventListener('click', function () {
            console.log("Inizio generazione PDF...");

            const selectedRisk = riskSelector.value;
            const currentRiskBaseColors = riskColorsData[selectedRisk] || {};
            const pdfSelectedRiskDisplayName = riskDisplayName[selectedRisk] || selectedRisk;

            // Define PDF specific styling (full opacity)
            const pdfStyleComune = (feature) => {
                const normalizedComuneNome = feature.properties.normalizedName;
                const base = getBaseForComune(normalizedComuneNome);
                let fillColor = '#ccc'; // Default for PDF

                if (base && currentRiskBaseColors[base]) {
                    fillColor = getHexColor(currentRiskBaseColors[base]);
                }

                return {
                    fillColor: fillColor,
                    weight: 1,
                    color: '#333',
                    fillOpacity: 1 // Full opacity for PDF capture
                };
            };

            // Temporarily apply PDF styles
            if (geoJsonLayer) {
                geoJsonLayer.setStyle(pdfStyleComune);
            }

            // Force reflow
            leafletMap.getContainer().style.display;

            setTimeout(function () {
                console.log("Chiamata leafletImage...");

                leafletImage(leafletMap, function (err, canvas) {
                    console.log("Callback di leafletImage eseguito.");

                    if (err) {
                        console.error("Errore in leafletImage:", err);
                        return;
                    }

                    const imgData = canvas.toDataURL('image/png');
                    const { jsPDF } = window.jspdf;
                    const pdf = new jsPDF('landscape');
                    const imgWidth = pdf.internal.pageSize.getWidth() - 20;
                    const imgHeight = (canvas.height * imgWidth) / canvas.width;

                    let currentY = 10; // Start Y position for elements

                    // Add Title
                    pdf.setFontSize(20);
                    pdf.text(`Bollettino Criticità - Rischio: ${pdfSelectedRiskDisplayName}`, 10, currentY);
                    currentY += 15;

                    // Add map image
                    pdf.addImage(imgData, 'PNG', 10, currentY, imgWidth, imgHeight);
                    currentY += imgHeight + 10;

                    // Add Last Updated Text
                    pdf.setFontSize(10);
                    pdf.text(lastUpdatedElement.textContent, 10, currentY);
                    currentY += 10;

                    // Add Logo (top right)
                    const logoImg = document.getElementById('region-logo');
                    if (logoImg) {
                        const logoData = logoImg.src;
                        const logoPdfWidth = 40;
                        const logoPdfHeight = (logoImg.naturalHeight * logoPdfWidth) / logoImg.naturalWidth;
                        const pdfPageWidth = pdf.internal.pageSize.getWidth();
                        pdf.addImage(logoData, 'PNG', pdfPageWidth - logoPdfWidth - 10, 10, logoPdfWidth, logoPdfHeight);
                    }

                    // Add Legend for the specific risk (bottom right)
                    let legendStartX = pdf.internal.pageSize.getWidth() - 60; // Adjust as needed
                    let legendY = currentY;

                    pdf.setFontSize(12);
                    pdf.text('Legenda:', legendStartX, legendY);
                    legendY += 5;

                    // Get sorted bases that have colors for the current risk
                    const sortedBasesForLegend = Object.keys(configurazioneCriticità).filter(base => currentRiskBaseColors[base]).sort((a, b) => {
                         const order = ['A1', 'A2', 'B', 'C', 'D', 'E1', 'E2'];
                         return order.indexOf(a) - order.indexOf(b);
                    });

                    sortedBasesForLegend.forEach((base) => {
                        const colorName = currentRiskBaseColors[base];
                        const hexColor = getHexColor(colorName);
                        pdf.setFillColor(hexColor);
                        pdf.rect(legendStartX, legendY + 2, 5, 5, 'F'); // Color box
                        pdf.setFontSize(10);
                        pdf.text(`Base ${base}: ${colorName.charAt(0).toUpperCase() + colorName.slice(1)}`, legendStartX + 8, legendY + 6);
                        legendY += 8;
                    });
                     // Add default entry for uncolored areas
                    pdf.setFillColor('#ccc');
                    pdf.rect(legendStartX, legendY + 2, 5, 5, 'F');
                    pdf.setFontSize(10);
                    pdf.text('Base Non Mappata / Nessun Rischio', legendStartX + 8, legendY + 6);


                    pdf.save(`bollettino_criticità_${pdfSelectedRiskDisplayName}_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.pdf`);

                    console.log("PDF generato e salvato.");

                    // Restore original map styles (for screen display)
                    if (geoJsonLayer) {
                        geoJsonLayer.setStyle(function (feature) {
                            return styleComune(feature, currentRiskBaseColors);
                        });
                    }
                });
            }, 1000); // Increased timeout for rendering
        });

        // Initialize the map and data
        initializeMap();

    </script>

</body>

</html>
