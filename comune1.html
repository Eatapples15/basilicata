<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="page-title">Criticità del Comune</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            padding: 20px;
            justify-content: center;
            align-items: flex-start;
            background-color: #f0f2f5;
        }

        #main-content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            width: 100%;
            max-width: 1200px;
        }

        #info-panel {
            flex: 1;
            min-width: 300px;
            max-width: 350px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 25px;
            border: 1px solid #ddd;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            background-color: #fff;
        }

        #map-container {
            flex: 2;
            min-width: 450px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        #leaflet-map {
            height: 600px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        h1,
        h2 {
            color: #333;
            margin-bottom: 10px;
        }

        p {
            color: #555;
            line-height: 1.6;
        }

        strong {
            color: #000;
        }

        #comune-name-display {
            font-size: 1.8em;
            font-weight: bold;
            color: #0056b3;
            margin-bottom: 5px;
        }

        #comune-criticity-display {
            font-size: 1.4em;
            font-weight: bold;
            color: #dc3545;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }

        #info-message {
            color: red;
            font-weight: bold;
            margin-top: 10px;
        }

        #last-updated {
            font-style: italic;
            color: #777;
            margin-top: 10px;
            font-size: 0.9em;
        }

        #region-logo {
            width: 100%;
            max-width: 180px;
            height: auto;
            margin-top: auto;
            align-self: center;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }

        /* Stili per i popup di Leaflet */
        .leaflet-popup-content-wrapper {
            background-color: white;
            color: #333;
            border-radius: 5px;
            padding: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .leaflet-popup-content {
            margin: 0;
        }

        .leaflet-popup-tip-container {
            width: 20px;
            height: 10px;
        }

        .leaflet-popup-tip {
            background: white;
            border: 1px solid #aaa;
            border-top-color: transparent;
            border-left-color: transparent;
        }

        /* Stili per le sezioni informative aggiuntive */
        .info-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }

        .info-section h3 {
            color: #333;
            margin-bottom: 10px;
        }

        ul {
            list-style-type: disc;
            margin-left: 20px;
            color: #666;
        }

        ul li {
            margin-bottom: 5px;
        }

        /* Stili per il pulsante di navigazione */
        #navigation-button {
            padding: 10px 15px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
            margin-top: 15px;
            align-self: center;
        }

        #navigation-button:hover {
            background-color: #218838;
        }

        /* Nuovo stile per il selettore dei rischi */
        #risk-selector-container {
            margin-bottom: 15px;
        }

        #risk-selector-container label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }

        #risk-selector {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 1em;
            background-color: #f9f9f9;
        }

        /* Stili per la legenda dei rischi (preview) */
        #risk-legend {
            background-color: #fff;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            margin-top: 20px;
            min-width: 450px;
            max-width: 700px;
        }

        #risk-legend h3 {
            margin-top: 0;
            color: #333;
            font-size: 1.2em;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            margin-bottom: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            cursor: pointer; /* Indica che è cliccabile */
            padding: 5px;
            border-radius: 5px;
            transition: background-color 0.2s ease;
        }

        .legend-item:hover {
            background-color: #f0f0f0;
        }

        .legend-color-box {
            width: 25px;
            height: 25px;
            border: 1px solid #888;
            margin-right: 10px;
            border-radius: 3px;
        }

        .legend-text {
            font-size: 1em;
            color: #555;
            flex-grow: 1; /* Permette al testo di occupare lo spazio rimanente */
        }

        .legend-item.active .legend-color-box {
            border: 2px solid #0056b3; /* Bordo più evidente per l'elemento selezionato */
        }
    </style>
</head>

<body>

    <div id="main-content">
        <div id="info-panel">
            <h1 id="comune-name-display"></h1>
            <p id="comune-criticity-display"></p>
            <p id="info-message"></p>
            <p id="last-updated"></p>

            <div class="info-section" id="risk-selector-container">
                <label for="risk-selector">Seleziona Tipo di Rischio:</label>
                <select id="risk-selector">
                    </select>
            </div>

            <div class="info-section">
                <h2>Informazioni sul Rischio Territoriale</h2>
                <p id="risk-info">Caricamento informazioni sui rischi...</p>
            </div>

            <div class="info-section">
                <h2>Aree di Accoglienza / Punti di Raccolta</h2>
                <p id="shelter-info">Caricamento informazioni sulle aree di accoglienza...</p>
            </div>

            <button id="navigation-button">
                Naviga all'area di accoglienza più vicina
            </button>

            <img src="Logo regione.png" alt="Logo Regione Basilicata" id="region-logo">
        </div>

        <div id="map-container">
            <div id="leaflet-map"></div>
            <div id="risk-legend">
                <h3>Legenda Rischi del Comune</h3>
                <div id="legend-items-container">
                    </div>
            </div>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/10.11.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.11.0/firebase-database-compat.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <script>
        // Your web app's Firebase configuration (IDENTICO ALLE ALTRE PAGINE)
        const firebaseConfig = {
            apiKey: "AIzaSyD1ABRI99tMtvFbbvjqyjbLImfgNMdRR28",
            authDomain: "bollettinoregionale.firebaseapp.com",
            projectId: "bollettinoregionale",
            databaseURL: "https://bollettinoregionale-default-rtdb.europe-west1.firebasedatabase.app/",
            storageBucket: "bollettinoregionale.appspot.com",
            messagingSenderId: "765538370497",
            appId: "1:765538370497:web:9c4f569754c0df01cc2540",
            // measurementId: "G-0BCQ0VRNXF" // measurementId è opzionale
        };

        // Initialize Firebase
        const app = firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        const leafletMap = L.map('leaflet-map');
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(leafletMap);

        // Elementi HTML
        const pageTitle = document.getElementById('page-title');
        const comuneNameDisplay = document.getElementById('comune-name-display');
        const comuneCriticityDisplay = document.getElementById('comune-criticity-display');
        const infoMessage = document.getElementById('info-message');
        const lastUpdatedElement = document.getElementById('last-updated');
        const riskInfoElement = document.getElementById('risk-info');
        const shelterInfoElement = document.getElementById('shelter-info');
        const navigationButton = document.getElementById('navigation-button');
        const riskSelector = document.getElementById('risk-selector');
        const riskLegendContainer = document.getElementById('legend-items-container'); // Nuovo contenitore per la legenda

        let geojsonDataGlobal = null;
        let criticitàMap = {};
        let coloriBase = {};
        let currentComuneNormalizedName = null;
        let currentComuneFeature = null; // Memorizza la feature GeoJSON del comune corrente

        // Layer per i controlli
        let baseLayers = {};
        let overlays = {};
        let comuneOutlineLayer = null;
        let criticitàFillLayer = null; // Questo sarà il layer del riempimento "base"
        let emergencyMarkersLayer = new L.LayerGroup();
        let riskSpecificFillLayer = new L.LayerGroup(); // Nuovo layer per il riempimento specifico del rischio

        // Normalizzazione dei nomi dei comuni
        function normalizeComuneName(nome) {
            if (!nome) return "";
            return nome.toLowerCase().trim().replace(/\s+/g, ' ').normalize("NFD").replace(/[\u0300-\u036f]/g, "");
        }

        // Funzione per ottenere il colore basato sulla criticità
        function getHexColor(colorName) {
            switch (colorName) {
                case 'green': return '#008000';
                case 'yellow': return '#FFFF00';
                case 'orange': return '#FFA500';
                case 'red': return '#FF0000';
                default: return '#ccc';
            }
        }

        // Funzione per definire lo stile di un comune sulla mappa (solo bordo per il layer "confine")
        function styleComuneOutline(feature) {
            return {
                fillColor: 'transparent',
                weight: 3,
                opacity: 1,
                color: 'black',
                fillOpacity: 0
            };
        }

        // Funzione per definire lo stile del riempimento di criticità (colore della base generale)
        function styleCriticitàFill(feature) {
            let normalizedComuneNome = feature.properties.normalizedName;
            const criticità = criticitàMap[normalizedComuneNome];
            const fillColor = coloriBase[criticità] || '#ccc';

            return {
                fillColor: getHexColor(fillColor),
                weight: 0,
                opacity: 0,
                color: 'transparent',
                fillOpacity: 0.9
            };
        }

        // Funzione per definire lo stile del riempimento per un rischio specifico (usando il colore della base generale)
        // Se avessi una criticità per ogni tipo di rischio, la logica qui cambierebbe.
        function styleSpecificRiskFill(feature) {
            let normalizedComuneNome = feature.properties.normalizedName;
            const criticità = criticitàMap[normalizedComuneNome]; // Usa la criticità generale per il colore
            const fillColor = coloriBase[criticità] || '#ccc';

            return {
                fillColor: getHexColor(fillColor),
                weight: 0,
                opacity: 0,
                color: 'transparent',
                fillOpacity: 0.9
            };
        }

        // Funzione per gestire i popup
        function onEachFeature(feature, layer) {
            if (feature.properties && feature.properties.name) {
                const normalizedComuneNome = feature.properties.normalizedName;
                const criticità = criticitàMap[normalizedComuneNome] || 'Non disponibile';
                layer.bindPopup(`<b>${feature.properties.name}</b><br>Base: ${criticità}`);
            }
        }

        // Funzione per recuperare il nome del comune dall'URL
        function getComuneFromUrl() {
            const params = new URLSearchParams(window.location.search);
            const comune = params.get('comune');
            return comune ? decodeURIComponent(comune) : null;
        }

        // Dati informativi per comune (ORA CON AREE DI ATTESA/EMERGENZA E RISCHI CATEGORIZZATI)
        const infoComuni = {
            "potenza": {
                rischi: {
                    generale: "Principali rischi: sismico, idrogeologico (frane e alluvioni in alcune zone).",
                    idrogeologico: "Rischio idrogeologico: frane e alluvioni possibili lungo il fiume Basento e in aree collinari con forte pendenza.",
                    sismico: "Rischio sismico: Potenza si trova in una zona ad alta sismicità. Importante seguire le norme di sicurezza.",
                    incendi: "Rischio incendi boschivi: elevato durante i mesi estivi, soprattutto nelle aree periurbane."
                },
                accoglienza: "Aree di accoglienza designate: Centro Polifunzionale di C.da Macchia Romana, Campo CONI. Punti di raccolta in Piazza Prefettura, Piazza Zara.",
                puntiMappa: [
                    { lat: 40.6409, lon: 15.7997, nome: "Piazza Prefettura (Punto Raccolta)", tipo: "raccolta" },
                    { lat: 40.6418, lon: 15.7951, nome: "Piazza Zara (Punto Raccolta)", tipo: "raccolta" },
                    { lat: 40.6622, lon: 15.8205, nome: "Centro Polifunzionale Macchia Romana (Area Accoglienza)", tipo: "accoglienza" },
                    { lat: 40.6385, lon: 15.7980, nome: "Campo CONI (Area Accoglienza)", tipo: "accoglienza" }
                ]
            },
            "matera": {
                rischi: {
                    generale: "Principali rischi: sismico, idrogeologico (zone dei Sassi e lungo il Torrente Gravina).",
                    idrogeologico: "Rischio idrogeologico: possibile esondazione del Torrente Gravina e instabilità dei versanti nei Sassi.",
                    sismico: "Rischio sismico: zona a sismicità media. Edifici storici richiedono attenzione.",
                    incendi: "Rischio incendi: moderato, con attenzione alle aree rurali circostanti."
                },
                accoglienza: "Aree di accoglienza designate: Palazzetto dello Sport in Via delle Nazioni Unite, Centro Giovanile. Punti di raccolta in Piazza Vittorio Veneto, Piazza Pascoli.",
                puntiMappa: [
                    { lat: 40.6657, lon: 16.6074, nome: "Piazza Vittorio Veneto (Punto Raccolta)", tipo: "raccolta" },
                    { lat: 40.6650, lon: 16.6110, nome: "Piazza Pascoli (Punto Raccolta)", tipo: "raccolta" },
                    { lat: 40.6720, lon: 16.5960, nome: "Palazzetto dello Sport (Area Accoglienza)", tipo: "accoglienza" }
                ]
            },
            "policoro": {
                rischi: {
                    generale: "Principali rischi: alluvioni (vicinanza al mare e fiumi), rischio costiero. Sismico moderato.",
                    idrogeologico: "Rischio alluvionale elevato a causa della pianura costiera e della vicinanza a corsi d'acqua come l'Agri e il Sinni. Rischio costiero dovuto a mareggiate e erosione.",
                    sismico: "Rischio sismico: moderato, ma è importante la prevenzione.",
                    incendi: "Rischio incendi: nelle aree agricole e costiere, soprattutto in estate."
                },
                accoglienza: "Aree di accoglienza: Palazzetto dello Sport. Punti di raccolta: Piazza Heraclea, lungomare.",
                puntiMappa: [
                    { lat: 40.1800, lon: 16.6660, nome: "Piazza Heraclea (Punto Raccolta)", tipo: "raccolta" },
                    { lat: 40.1870, lon: 16.6620, nome: "Palazzetto dello Sport (Area Accoglienza)", tipo: "accoglienza" }
                ]
            },
            "melfi": {
                rischi: {
                    generale: "Principali rischi: sismico, vulcanico (vicinanza al Vulture), idrogeologico.",
                    idrogeologico: "Rischio idrogeologico: frane e smottamenti possibili per la conformazione del territorio.",
                    sismico: "Rischio sismico: Melfi è in una zona a sismicità medio-alta, necessaria attenzione.",
                    vulcanico: "Rischio vulcanico: sebbene il Vulture sia spento, è importante monitorare fenomeni secondari (attività idrotermale, piccole emissioni di gas).",
                    incendi: "Rischio incendi boschivi: elevato nelle aree forestali circostanti il Vulture."
                },
                accoglienza: "Aree di accoglienza: Centro Sportivo. Punti di raccolta: Piazza Duomo, Piazza Vescovado.",
                puntiMappa: [
                    { lat: 40.9990, lon: 15.6510, nome: "Piazza Duomo (Punto Raccolta)", tipo: "raccolta" },
                    { lat: 41.0020, lon: 15.6550, nome: "Piazza Vescovado (Punto Raccolta)", tipo: "raccolta" },
                    { lat: 40.9950, lon: 15.6450, nome: "Centro Sportivo (Area Accoglienza)", tipo: "accoglienza" }
                ]
            }
            // Aggiungi altri comuni qui con i loro 'rischi' categorizzati e 'puntiMappa'
        };


        // Definisci le icone personalizzate per i marker
        const shelterIcon = L.icon({
            iconUrl: 'ico/cluster_shelter_32px_icon_bluebox.png',
            iconSize: [32, 32],
            iconAnchor: [16, 32],
            popupAnchor: [0, -32],
            shadowUrl: 'ico/marker-shadow.png',
            shadowSize: [41, 41]
        });

        const emergencyIcon = L.icon({
            iconUrl: 'ico/disaster_earthquake_32px_icon_bluebox.png',
            iconSize: [32, 32],
            iconAnchor: [16, 32],
            popupAnchor: [0, -32],
            shadowUrl: 'ico/marker-shadow.png',
            shadowSize: [41, 41]
        });

        // Carica dati GeoJSON e colori Firebase all'avvio
        Promise.all([
            fetch('limits_R_17_municipalities.geojson').then(res => res.json()),
            database.ref('colori').once('value')
        ]).then(([geojsonData, snapshot]) => {
            geojsonDataGlobal = geojsonData;

            // Normalizza i nomi dei comuni nel GeoJSON
            geojsonDataGlobal.features.forEach(feature => {
                if (feature.properties && feature.properties.name) {
                    feature.properties.normalizedName = normalizeComuneName(feature.properties.name);
                }
            });

            if (snapshot.exists()) {
                const datiColori = snapshot.val();
                coloriBase = datiColori.coloriBase || {};
                const timestamp = new Date(datiColori.dataCreazione);
                lastUpdatedElement.textContent = `Dati aggiornati il: ${timestamp.toLocaleString()}`;

                const configurazioneCriticità = {
                    'A1': ["Montemilone", "Atella", "Palazzo San Gervasio", "Pescopagano", "Rapolla", "Rapone", "Rionero in Vulture", "Ripacandida", "Ruvo del Monte", "San Fele", "Filiano", "Forenza", "Lavello", "Barile", "Maschito", "Melfi", "Venosa", "Ginestra"],
                    'A2': ["Muro Lucano", "Balvano", "Baragiano", "Bella", "Brienza", "Castelgrande", "Picerno", "Ruoti", "Sant'Angelo Le Fratte", "Sasso di Castalda", "Satriano di Lucania", "Savoia di Lucania", "Tito", "Vietri di Potenza"],
                    'B': ["Abriola", "Accettura", "Acerenza", "Albano di Lucania", "Anzi", "Avigliano", "Banzi", "Brindisi Montagna", "Calciano", "Calvello", "Campomaggiore", "Cancellara", "Castelmezzano", "Ferrandina", "Filiano", "Forenza", "Garaguso", "Genzano di Lucania", "Grassano", "Grottole", "Irsina", "Laurenzana", "Miglionico", "Oliveto Lucano", "Oppido Lucano", "Pietragalla", "Pietrapertosa", "Pignola", "Pomarico", "Potenza", "Salandra", "San Chirico Nuovo", "San Mauro Forte", "Tito", "Tolve", "Tricarico", "Trivigno", "Vaglio Basilicata", "Matera"],
                    'C': ["Montemurro", "Aliano", "Armento", "Calvera", "Carbone", "Castronuovo di Sant'Andrea", "Cersosimo", "Chiaromonte", "Cirigliano", "Colobraro", "Corleto Perticara", "Episcopia", "Fardella", "Francavilla in Sinni", "Gallicchio", "Gorgoglione", "Grumento Nova", "Guardia Perticara", "Marsico Nuovo", "Marsicovetere", "Missanello", "Moliterno", "Noepoli", "Paterno", "Roccanova", "San Chirico Raparo", "San Costantino Albanese", "San Giorgio Lucano", "San Martino d'Agri", "San Paolo Albanese", "San Severino Lucano", "Sant'Arcangelo", "Sarconi", "Senise", "Spinoso", "Stigliano", "Teana", "Terranova di Pollino", "Tramutola", "Tursi", "Valsinni", "Viggiano"],
                    'D': ["Nemoli", "Castelluccio Inferiore", "Castelluccio Superiore", "Castelsaraceno", "Lagonegro", "Latronico", "Lauria", "Maratea", "Rivello", "Rotonda", "Trecchina", "Viggianello"],
                    'E1': ["Nova Siri", "Policoro", "Rotondella", "Scanzano Jonico", "Tursi", "Montalbano Jonico", "Craco"],
                    'E2': ["Montescaglioso", "Bernalda", "Pisticci", "Pomarico", "Ferrandina"]
                };

                for (const base in configurazioneCriticità) {
                    const comuni = configurazioneCriticità[base];
                    comuni.forEach(comune => {
                        criticitàMap[normalizeComuneName(comune)] = base;
                    });
                }

                const targetComuneNome = getComuneFromUrl();
                if (targetComuneNome) {
                    displayComuneInfo(targetComuneNome);
                } else {
                    infoMessage.textContent = "Nessun comune specificato nell'URL. Utilizza '?comune=NomeComune'.";
                    comuneNameDisplay.textContent = "Comune non specificato";
                    comuneCriticityDisplay.textContent = "";
                    riskInfoElement.textContent = "Nessuna informazione disponibile.";
                    shelterInfoElement.textContent = "Nessuna informazione disponibile.";
                    leafletMap.setView([40.6393, 15.8054], 8);
                    // Nascondi il selettore e la legenda se il comune non è specificato
                    riskSelector.style.display = 'none';
                    document.getElementById('risk-selector-container').style.display = 'none';
                    document.getElementById('risk-legend').style.display = 'none';
                }

            } else {
                lastUpdatedElement.textContent = 'Nessun dato colore disponibile da Firebase.';
                console.warn("Nessun dato colore trovato in Firebase.");
            }
        }).catch(error => {
            console.error("Errore nel caricamento dei dati:", error);
            infoMessage.textContent = 'Errore nel caricamento dei dati. Riprova più tardi.';
        });

        // Funzione per popolare il selettore dei rischi
        function populateRiskSelector(comuneNormalizedName) {
            riskSelector.innerHTML = '';
            const comuneInfo = infoComuni[comuneNormalizedName];

            if (comuneInfo && comuneInfo.rischi) {
                document.getElementById('risk-selector-container').style.display = 'block';

                const defaultOption = document.createElement('option');
                defaultOption.value = 'generale';
                defaultOption.textContent = 'Rischio Generale';
                riskSelector.appendChild(defaultOption);

                for (const riskType in comuneInfo.rischi) {
                    if (riskType !== 'generale') {
                        const option = document.createElement('option');
                        option.value = riskType;
                        option.textContent = riskType.charAt(0).toUpperCase() + riskType.slice(1).replace(/([A-Z])/g, ' $1').trim();
                        riskSelector.appendChild(option);
                    }
                }
                riskSelector.value = 'generale'; // Seleziona il rischio generale di default
            } else {
                const noOption = document.createElement('option');
                noOption.value = '';
                noOption.textContent = 'Nessun rischio specifico disponibile';
                riskSelector.appendChild(noOption);
                document.getElementById('risk-selector-container').style.display = 'none';
            }
        }

        // Funzione per aggiornare il testo del rischio e la colorazione della mappa
        function updateRiskInfoAndMapDisplay(selectedRiskType) {
            const comuneInfo = infoComuni[currentComuneNormalizedName];
            if (comuneInfo && comuneInfo.rischi && comuneInfo.rischi[selectedRiskType]) {
                riskInfoElement.textContent = comuneInfo.rischi[selectedRiskType];
            } else {
                riskInfoElement.textContent = "Informazioni sul rischio non disponibili per il tipo selezionato.";
            }

            // Aggiorna la colorazione della mappa
            updateMapColoration(selectedRiskType);
        }

        // Funzione per aggiornare la colorazione della mappa in base al rischio selezionato
        function updateMapColoration(selectedRiskType) {
            // Rimuovi tutti i layer specifici per rischio precedentemente aggiunti
            riskSpecificFillLayer.clearLayers();

            if (currentComuneFeature) {
                const criticità = criticitàMap[currentComuneNormalizedName];
                const fillColor = coloriBase[criticità] || '#ccc';

                const style = {
                    fillColor: getHexColor(fillColor),
                    weight: 0,
                    opacity: 0,
                    color: 'transparent',
                    fillOpacity: 0.9
                };

                // Se la selezione è "generale", usa il layer di criticità generale
                if (selectedRiskType === 'generale') {
                    if (criticitàFillLayer) {
                        criticitàFillLayer.addTo(leafletMap);
                    }
                    // Assicurati che gli altri layer specifici non siano presenti
                    riskSpecificFillLayer.clearLayers();
                } else {
                    // Per qualsiasi altro rischio, colora il comune con il colore della sua criticità generale
                    // Potresti voler modificare questa logica se hai criticità specifiche per ogni tipo di rischio.
                    const newRiskLayer = L.geoJSON(currentComuneFeature, {
                        style: style,
                        onEachFeature: onEachFeature
                    });
                    riskSpecificFillLayer.addLayer(newRiskLayer);
                    riskSpecificFillLayer.addTo(leafletMap);

                    // Rimuovi il layer di criticità generale se c'è un rischio specifico selezionato
                    if (criticitàFillLayer && leafletMap.hasLayer(criticitàFillLayer)) {
                        leafletMap.removeLayer(criticitàFillLayer);
                    }
                }
            }

            // Aggiorna lo stato "active" nella legenda
            document.querySelectorAll('.legend-item').forEach(item => {
                item.classList.remove('active');
            });
            const activeLegendItem = document.querySelector(`.legend-item[data-risk-type="${selectedRiskType}"]`);
            if (activeLegendItem) {
                activeLegendItem.classList.add('active');
            }
        }


        // Funzione per popolare la legenda dei rischi
        function populateRiskLegend(comuneNormalizedName) {
            riskLegendContainer.innerHTML = ''; // Pulisci la legenda esistente
            const comuneInfo = infoComuni[comuneNormalizedName];

            if (comuneInfo && comuneInfo.rischi) {
                document.getElementById('risk-legend').style.display = 'block';

                const criticità = criticitàMap[comuneNormalizedName];
                const colorHex = getHexColor(coloriBase[criticità] || '#ccc');

                // Aggiungi l'elemento "Rischio Generale"
                const generalItem = document.createElement('div');
                generalItem.classList.add('legend-item');
                generalItem.setAttribute('data-risk-type', 'generale');
                generalItem.innerHTML = `
                    <div class="legend-color-box" style="background-color: ${colorHex};"></div>
                    <span class="legend-text">Rischio Generale: ${criticità}</span>
                `;
                generalItem.addEventListener('click', () => {
                    riskSelector.value = 'generale';
                    updateRiskInfoAndMapDisplay('generale');
                });
                riskLegendContainer.appendChild(generalItem);

                // Aggiungi gli elementi per ogni rischio specifico
                for (const riskType in comuneInfo.rischi) {
                    if (riskType !== 'generale') {
                        const item = document.createElement('div');
                        item.classList.add('legend-item');
                        item.setAttribute('data-risk-type', riskType);
                        item.innerHTML = `
                            <div class="legend-color-box" style="background-color: ${colorHex};"></div>
                            <span class="legend-text">${riskType.charAt(0).toUpperCase() + riskType.slice(1).replace(/([A-Z])/g, ' $1').trim()}</span>
                        `;
                        item.addEventListener('click', () => {
                            riskSelector.value = riskType;
                            updateRiskInfoAndMapDisplay(riskType);
                        });
                        riskLegendContainer.appendChild(item);
                    }
                }
            } else {
                document.getElementById('risk-legend').style.display = 'none'; // Nascondi la legenda
            }
        }


        // Aggiungi un event listener al selettore per aggiornare le informazioni e la mappa
        riskSelector.addEventListener('change', (event) => {
            updateRiskInfoAndMapDisplay(event.target.value);
        });

        // Funzione per visualizzare le informazioni del comune
        function displayComuneInfo(comuneOriginalName) {
            const normalizedComuneName = normalizeComuneName(comuneOriginalName);
            currentComuneNormalizedName = normalizedComuneName;
            const foundFeature = geojsonDataGlobal.features.find(feature =>
                feature.properties.normalizedName === normalizedComuneName
            );

            // Rimuovi tutti i layer dal controllo e dalla mappa
            if (comuneOutlineLayer) leafletMap.removeLayer(comuneOutlineLayer);
            if (criticitàFillLayer) leafletMap.removeLayer(criticitàFillLayer);
            emergencyMarkersLayer.clearLayers();
            riskSpecificFillLayer.clearLayers(); // Pulisci anche il layer dei rischi specifici

            // Rimuovi il controllo layer esistente se presente
            const existingLayerControl = document.querySelector('.leaflet-control-layers');
            if (existingLayerControl) {
                existingLayerControl.remove();
            }
            baseLayers = {};
            overlays = {};


            if (foundFeature) {
                currentComuneFeature = foundFeature; // Salva la feature per uso futuro
                pageTitle.textContent = `Criticità del Comune di ${foundFeature.properties.name}`;
                comuneNameDisplay.textContent = `Comune: ${foundFeature.properties.name}`;

                const criticità = criticitàMap[foundFeature.properties.normalizedName] || 'Non disponibile';
                comuneCriticityDisplay.textContent = `Base: ${criticità}`;

                // Creo i layer GeoJSON per il comune specifico
                comuneOutlineLayer = L.geoJSON(foundFeature, {
                    style: styleComuneOutline,
                    onEachFeature: onEachFeature
                });

                // Il layer di riempimento generale, inizialmente visibile
                criticitàFillLayer = L.geoJSON(foundFeature, {
                    style: styleCriticitàFill,
                    onEachFeature: onEachFeature
                });


                // Aggiungo i layer agli overlays e li attivo di default
                overlays["Confine Comunale"] = comuneOutlineLayer;
                overlays["Criticità Generale"] = criticitàFillLayer; // Rinominato per chiarezza

                comuneOutlineLayer.addTo(leafletMap);
                criticitàFillLayer.addTo(leafletMap); // Attivato di default

                // Centra la mappa sul comune trovato
                leafletMap.fitBounds(comuneOutlineLayer.getBounds().pad(0.5));

                // Carica e visualizza le informazioni aggiuntive
                const comuneInfo = infoComuni[normalizedComuneName];
                if (comuneInfo) {
                    populateRiskSelector(normalizedComuneName);
                    populateRiskLegend(normalizedComuneName); // Popola la legenda
                    updateRiskInfoAndMapDisplay(riskSelector.value); // Aggiorna info e mappa in base al default del selettore

                    shelterInfoElement.textContent = comuneInfo.accoglienza;

                    if (comuneInfo.puntiMappa && comuneInfo.puntiMappa.length > 0) {
                        comuneInfo.puntiMappa.forEach(punto => {
                            let markerIcon;
                            if (punto.tipo === 'raccolta') {
                                markerIcon = emergencyIcon;
                            } else if (punto.tipo === 'accoglienza') {
                                markerIcon = shelterIcon;
                            } else {
                                markerIcon = L.Icon.Default;
                            }

                            const marker = L.marker([punto.lat, punto.lon], { icon: markerIcon })
                                .bindPopup(`<b>${punto.nome}</b><br>Tipo: ${punto.tipo}`);
                            emergencyMarkersLayer.addLayer(marker);
                        });
                        overlays["Aree di Emergenza/Accoglienza"] = emergencyMarkersLayer;
                        emergencyMarkersLayer.addTo(leafletMap);

                        navigationButton.removeEventListener('click', navigateToShelter);
                        navigationButton.addEventListener('click', navigateToShelter);
                        navigationButton.style.display = 'block';

                    } else {
                        shelterInfoElement.textContent += " (Nessun punto specifico su mappa disponibile).";
                        navigationButton.style.display = 'none';
                    }

                } else {
                    riskInfoElement.textContent = "Informazioni sui rischi non disponibili per questo comune.";
                    shelterInfoElement.textContent = "Informazioni sulle aree di accoglienza non disponibili per questo comune.";
                    navigationButton.style.display = 'none';
                    document.getElementById('risk-selector-container').style.display = 'none';
                    document.getElementById('risk-legend').style.display = 'none';
                }

                // Aggiungi il controllo layer alla mappa
                L.control.layers(baseLayers, overlays).addTo(leafletMap);

            } else {
                infoMessage.textContent = `Comune "${comuneOriginalName}" non trovato nella mappa. Verifica il nome.`;
                comuneNameDisplay.textContent = `Comune: ${comuneOriginalName}`;
                comuneCriticityDisplay.textContent = 'Criticità: Non trovata';
                riskInfoElement.textContent = "Informazioni sui rischi non disponibili.";
                shelterInfoElement.textContent = "Informazioni sulle aree di accoglienza non disponibili.";
                leafletMap.setView([40.6393, 15.8054], 8);
                navigationButton.style.display = 'none';
                document.getElementById('risk-selector-container').style.display = 'none';
                document.getElementById('risk-legend').style.display = 'none';
            }
        }

        function navigateToShelter() {
            const comuneInfo = infoComuni[currentComuneNormalizedName];
            if (comuneInfo && comuneInfo.puntiMappa) {
                const nearestShelter = comuneInfo.puntiMappa.find(punto => punto.tipo === 'accoglienza');
                if (nearestShelter) {
                    const googleMapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${nearestShelter.lat},${nearestShelter.lon}&travelmode=walking`;
                    window.open(googleMapsUrl, '_blank');
                } else {
                    alert('Nessuna area di accoglienza disponibile per questo comune.');
                }
            }
        }

    </script>

</body>

</html>
