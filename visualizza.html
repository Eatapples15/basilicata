<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizza Mappa Criticità per Rischio</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            padding: 20px;
        }

        #leaflet-map {
            flex: 2;
            min-width: 300px;
            height: 500px;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        #info-container {
            flex: 1;
            min-width: 200px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            background-color: #f9f9f9;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        select {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
            font-size: 16px;
        }

        #current-risk-legend {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px dashed #ccc;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .legend-color-box {
            width: 20px;
            height: 20px;
            border: 1px solid #777;
            margin-right: 8px;
            flex-shrink: 0;
        }

        #last-updated {
            font-style: italic;
            color: #777;
        }

        #save-pdf-button {
            padding: 10px 15px;
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 20px;
            transition: background-color 0.3s ease;
        }

        #save-pdf-button:hover {
            background-color: #c82333;
        }

        #region-logo {
            width: 100%;
            max-width: 200px;
            height: auto;
            margin-top: auto;
            align-self: center;
            padding-top: 20px;
        }

        /* Leaflet popup styles */
        .leaflet-popup-content-wrapper {
            background-color: white;
            color: #333;
            border-radius: 5px;
            padding: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .leaflet-popup-content {
            margin: 0;
        }

        .leaflet-popup-tip-container {
            width: 20px;
            height: 10px;
        }

        .leaflet-popup-tip {
            background: white;
            border: 1px solid #aaa;
            border-top-color: transparent;
            border-left-color: transparent;
        }
    </style>
</head>

<body>

    <div id="leaflet-map"></div>

    <div id="info-container">
        <div class="form-group">
            <label for="day-selector">Seleziona Giorno:</label>
            <select id="day-selector">
                <option value="oggi">Oggi</option>
                <option value="domani">Domani</option>
                <option value="riassunto">Riassunto</option>
            </select>
        </div>

        <div class="form-group">
            <label for="risk-selector">Seleziona Rischio:</label>
            <select id="risk-selector">
            </select>
        </div>

        <div id="current-risk-legend">
            <h4>Legenda Rischio Corrente:</h4>
        </div>

        <h3>Ultimo Aggiornamento</h3>
        <p id="last-updated"></p>
        <button id="save-pdf-button">Scarica come PDF</button>

        <img src="Logo regione.png" alt="Logo Regione Basilicata" id="region-logo">
    </div>

    <script src="https://www.gstatic.com/firebasejs/10.11.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.11.0/firebase-database-compat.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://unpkg.com/leaflet-image@latest/leaflet-image.js"></script>

    <script>
        // La configurazione di Firebase è identica a `index.html`
        const firebaseConfig = {
            apiKey: "AIzaSyD1ABRI99tMtvFbbvjqyjbLImfgNMdRR28",
            authDomain: "bollettinoregionale.firebaseapp.com",
            projectId: "bollettinoregionale",
            databaseURL: "https://bollettinoregionale-default-rtdb.europe-west1.firebasedatabase.app/",
            storageBucket: "bollettinoregionale.appspot.com",
            messagingSenderId: "765538370497",
            appId: "1:765538370497:web:9c4f569754c0df01cc2540",
            // measurementId: "G-0BCQ0VRNXF" // measurementId è opzionale
        };

        // Inizializza Firebase
        const app = firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        const leafletMap = L.map('leaflet-map').setView([40.6393, 15.8054], 8);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(leafletMap);

        const lastUpdatedElement = document.getElementById('last-updated');
        const savePdfButton = document.getElementById('save-pdf-button');
        const riskSelector = document.getElementById('risk-selector');
        const daySelector = document.getElementById('day-selector'); // Nuovo selettore per il giorno
        const currentRiskLegend = document.getElementById('current-risk-legend');

        let criticitàMap = {}; // Mappa: nome comune normalizzato -> sua 'Base' (es. "potenza" -> "B")
        let riskColorsData = {}; // Memorizza i colori per ogni base, per tipo di rischio e per giorno (es. {'IdrogeologicoTemporali': {'oggi': {'A1': 'red'}, 'domani': {'A1': 'yellow'}}})
        let geoJsonLayer = null; // Memorizza il layer Leaflet GeoJSON
        let loadedGeojsonData = null; // Cache per i dati GeoJSON

        // Mappa i nomi delle chiavi dei rischi ai nomi da visualizzare.
        // ATTENZIONE: Questi nomi DEVONO corrispondere esattamente ai nomi dei nodi su Firebase
        // (es. "IdrogeologicoTemporali" e non "idrogeologico_temporali").
        const riskDisplayName = {
            'IdrogeologicoTemporali': 'Idrogeologico (Temporali)',
            'Idrogeologico': 'Idrogeologico',
            'Idraulico': 'Idraulico',
            'Incendio': 'Incendio'
        };

        // Normalizzazione dei nomi dei comuni (identica a prima)
        function normalizeComuneName(nome) {
            if (!nome) return "";
            return nome.toLowerCase().trim().replace(/\s+/g, ' ').normalize("NFD").replace(/[\u0300-\u036f]/g, "");
        }

        // Funzione per ottenere il codice esadecimale da un nome di colore (identica a prima)
        function getHexColor(colorName) {
            switch (colorName.toLowerCase()) { // Converti in minuscolo per confronto
                case 'green': return '#008000';
                case 'yellow': return '#FFFF00';
                case 'orange': return '#FFA500';
                case 'red': return '#FF0000';
                default: return '#ccc'; // Grigio di default per colori mancanti
            }
        }

        // Funzione per confrontare i colori e determinare il "peggiore"
        function getWorseColor(color1, color2) {
            const riskOrder = { 'green': 0, 'yellow': 1, 'orange': 2, 'red': 3 };
            const r1 = riskOrder[color1.toLowerCase()] !== undefined ? riskOrder[color1.toLowerCase()] : -1;
            const r2 = riskOrder[color2.toLowerCase()] !== undefined ? riskOrder[color2.toLowerCase()] : -1;

            if (r1 === -1 && r2 === -1) return 'green'; // Se entrambi non mappati, considera verde (nessun rischio)
            if (r1 === -1) return color2; // Se color1 non mappato, color2 è il peggiore
            if (r2 === -1) return color1; // Se color2 non mappato, color1 è il peggiore

            return r1 > r2 ? color1 : color2;
        }


        // Configurazione delle basi di criticità e dei loro comuni (identica a prima)
        const configurazioneCriticità = {
            'A1': ["Montemilone", "Atella", "Palazzo San Gervasio", "Pescopagano", "Rapolla", "Rapone", "Rionero in Vulture", "Ripacandida", "Ruvo del Monte", "San Fele", "Filiano", "Forenza", "Lavello", "Barile", "Maschito", "Melfi", "Venosa", "Ginestra"],
            'A2': ["Muro Lucano", "Balvano", "Baragiano", "Bella", "Brienza", "Castelgrande", "Picerno", "Ruoti", "Sant'Angelo Le Fratte", "Sasso di Castalda", "Satriano di Lucania", "Savoia di Lucania", "Tito", "Vietri di Potenza"],
            'B': ["Abriola", "Accettura", "Acerenza", "Albano di Lucania", "Anzi", "Avigliano", "Banzi", "Brindisi Montagna", "Calciano", "Calvello", "Campomaggiore", "Cancellara", "Castelmezzano", "Ferrandina", "Filiano", "Forenza", "Garaguso", "Genzano di Lucania", "Grassano", "Grottole", "Irsina", "Laurenzana", "Miglionico", "Oliveto Lucano", "Oppido Lucano", "Pietragalla", "Pietrapertosa", "Pignola", "Pomarico", "Potenza", "Salandra", "San Chirico Nuovo", "San Mauro Forte", "Tito", "Tolve", "Tricarico", "Trivigno", "Vaglio Basilicata", "Matera"],
            'C': ["Montemurro", "Aliano", "Armento", "Calvera", "Carbone", "Castronuovo di Sant'Andrea", "Cersosimo", "Chiaromonte", "Cirigliano", "Colobraro", "Corleto Perticara", "Episcopia", "Fardella", "Francavilla in Sinni", "Gallicchio", "Gorgoglione", "Grumento Nova", "Guardia Perticara", "Marsico Nuovo", "Marsicovetere", "Missanello", "Moliterno", "Noepoli", "Paterno", "Roccanova", "San Chirico Raparo", "San Costantino Albanese", "San Giorgio Lucano", "San Martino d'Agri", "San Paolo Albanese", "San Severino Lucano", "Sant'Arcangelo", "Sarconi", "Senise", "Spinoso", "Stigliano", "Teana", "Terranova di Pollino", "Tramutola", "Tursi", "Valsinni", "Viggiano"],
            'D': ["Nemoli", "Castelluccio Inferiore", "Castelluccio Superiore", "Castelsaraceno", "Lagonegro", "Latronico", "Lauria", "Maratea", "Rivello", "Rotonda", "Trecchina", "Viggianello"],
            'E1': ["Nova Siri", "Policoro", "Rotondella", "Scanzano Jonico", "Tursi", "Montalbano Jonico", "Craco"],
            'E2': ["Montescaglioso", "Bernalda", "Pisticci", "Pomarico", "Ferrandina"]
        };

        // Costruisci la mappa di criticità (nome comune normalizzato -> base) una volta sola all'avvio
        for (const base in configurazioneCriticità) {
            const comuni = configurazioneCriticità[base];
            comuni.forEach(comune => {
                const normalizedComune = normalizeComuneName(comune);
                criticitàMap[normalizedComune] = base;
            });
        }

        // Funzione per ottenere la base geografica per un dato comune normalizzato
        function getBaseForComune(comuneNome) {
            return criticitàMap[comuneNome];
        }

        // Funzione principale per inizializzare la mappa: recupera i dati, popola i selettori e mostra la mappa
        async function initializeMap() {
            try {
                // Carica il file GeoJSON una sola volta
                const response = await fetch('limits_R_17_municipalities.geojson');
                loadedGeojsonData = await response.json();

                // Pre-processa loadedGeojsonData per aggiungere i nomi normalizzati
                loadedGeojsonData.features.forEach(feature => {
                    if (feature.properties && feature.properties.name) {
                        feature.properties.normalizedName = normalizeComuneName(feature.properties.name);
                    }
                });

                // Recupera i colori dei rischi da Firebase dal nodo 'colori'
                const snapshot = await database.ref('colori').once('value');

                if (snapshot.exists()) {
                    const datiColori = snapshot.val();

                    // Ora riskColorsData prende i dati dal nodo 'rischi'
                    riskColorsData = datiColori.rischi || {};

                    // Recupera il timestamp dal nodo 'dataCreazione' (direttamente sotto 'colori')
                    const timestampString = datiColori.dataCreazione;
                    if (timestampString) {
                        const timestamp = new Date(timestampString);
                        const formattedDate = timestamp.toLocaleString();
                        lastUpdatedElement.textContent = `Aggiornato il: ${formattedDate}`;
                    } else {
                        lastUpdatedElement.textContent = 'Data di aggiornamento non disponibile.';
                    }

                    // Popola il menu a discesa dei rischi
                    const riskTypes = Object.keys(riskColorsData).filter(key => key !== 'dataCreazione');
                    riskSelector.innerHTML = ''; // Pulisci le opzioni esistenti

                    if (riskTypes.length === 0) {
                        const option = document.createElement('option');
                        option.value = '';
                        option.textContent = 'Nessun rischio disponibile';
                        riskSelector.appendChild(option);
                        riskSelector.disabled = true; // Disabilita il selettore se non ci sono rischi
                    } else {
                        // Ordina i tipi di rischio per visualizzarli in un ordine consistente
                        const orderedRiskTypes = ['Idrogeologico', 'IdrogeologicoTemporali', 'Idraulico', 'Incendio'];
                        riskTypes.sort((a, b) => {
                            const indexA = orderedRiskTypes.indexOf(a);
                            const indexB = orderedRiskTypes.indexOf(b);
                            if (indexA === -1 && indexB === -1) return 0; // Entrambi non nell'ordine predefinito
                            if (indexA === -1) return 1; // a non nell'ordine, b lo è (a va dopo)
                            if (indexB === -1) return -1; // b non nell'ordine, a lo è (b va dopo)
                            return indexA - indexB;
                        });

                        orderedRiskTypes.forEach(riskKey => {
                            if (riskTypes.includes(riskKey)) { // Aggiungi solo se il rischio esiste in Firebase
                                const option = document.createElement('option');
                                option.value = riskKey;
                                option.textContent = riskDisplayName[riskKey] || riskKey; // Usa il nome visualizzato se disponibile
                                riskSelector.appendChild(option);
                            }
                        });

                        riskSelector.disabled = false;

                        // Cerca il parametro 'risk' nell'URL
                        const urlParams = new URLSearchParams(window.location.search);
                        const initialRisk = urlParams.get('risk');
                        if (initialRisk && riskTypes.includes(initialRisk)) {
                            riskSelector.value = initialRisk; // Seleziona il rischio dall'URL
                        } else {
                            // Se non c'è un parametro o è invalido, imposta la prima opzione come selezionata di default
                            riskSelector.value = riskTypes[0];
                        }
                    }

                    // Imposta la visualizzazione iniziale della mappa e della legenda
                    updateMapAndLegend();

                    // Aggiungi i listener per il cambio di selezione nei menu
                    riskSelector.addEventListener('change', updateMapAndLegend);
                    daySelector.addEventListener('change', updateMapAndLegend);

                } else {
                    lastUpdatedElement.textContent = 'Nessun dato colore disponibile su Firebase.';
                    riskSelector.disabled = true;
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = 'Nessun dato rischio';
                    riskSelector.appendChild(option);
                }
            } catch (error) {
                console.error("Errore durante l'inizializzazione della mappa:", error);
                lastUpdatedElement.textContent = 'Errore nel caricamento dei dati.';
            }
        }

        // Funzione per ottenere i colori per il giorno e il rischio selezionati
        function getColorsForCurrentSelection() {
            const selectedRisk = riskSelector.value;
            const selectedDay = daySelector.value;

            if (selectedDay === 'riassunto') {
                const summaryColors = {};
                const allRiskTypes = Object.keys(riskColorsData).filter(key => key !== 'dataCreazione');

                // Itera su tutte le basi
                for (const base in configurazioneCriticità) {
                    let worstColorForBase = 'green'; // Partiamo dal verde (nessun rischio)

                    // Per ogni base, considera tutti i rischi per oggi e domani
                    allRiskTypes.forEach(riskType => {
                        const colorsForRiskToday = riskColorsData[riskType] ? (riskColorsData[riskType]['oggi'] || {}) : {};
                        const colorsForRiskTomorrow = riskColorsData[riskType] ? (riskColorsData[riskType]['domani'] || {}) : {};

                        const colorToday = colorsForRiskToday[base] || 'green';
                        const colorTomorrow = colorsForRiskTomorrow[base] || 'green';

                        // Confronta i colori di oggi e domani per il rischio corrente
                        const worseOfDay = getWorseColor(colorToday, colorTomorrow);
                        // Confronta il peggiore dei due giorni con il peggiore trovato finora per questa base
                        worstColorForBase = getWorseColor(worstColorForBase, worseOfDay);
                    });
                    summaryColors[base] = worstColorForBase;
                }
                return summaryColors;
            } else {
                return riskColorsData[selectedRisk] ? (riskColorsData[selectedRisk][selectedDay] || {}) : {};
            }
        }


        // Funzione per aggiornare la mappa e la legenda in base al rischio e al giorno selezionati
        function updateMapAndLegend() {
            const selectedDay = daySelector.value;
            const selectedRisk = riskSelector.value;

            // Abilita/disabilita il selettore rischio in base al giorno selezionato
            riskSelector.disabled = (selectedDay === 'riassunto');

            const currentColors = getColorsForCurrentSelection();

            // Rimuovi il layer GeoJSON esistente dalla mappa
            if (geoJsonLayer) {
                leafletMap.removeLayer(geoJsonLayer);
            }

            // Aggiungi un nuovo layer GeoJSON con gli stili aggiornati
            geoJsonLayer = L.geoJSON(loadedGeojsonData, {
                style: function (feature) {
                    return styleComune(feature, currentColors);
                },
                onEachFeature: onEachFeature
            }).addTo(leafletMap);

            updateLegend(currentColors); // Aggiorna la legenda
        }


        // Funzione per determinare lo stile del comune (colore e opacità)
        function styleComune(feature, currentColors) {
            const normalizedComuneNome = feature.properties.normalizedName;
            const base = getBaseForComune(normalizedComuneNome); // Ottieni la base geografica (A1, B, ecc.)

            let fillColor = '#ccc'; // Colore di default per comuni non mappati o senza colore per il rischio selezionato
            const fillOpacity = 0.7;

            // Se la base esiste e c'è un colore definito per quella base nella selezione corrente
            if (base && currentColors[base]) {
                fillColor = getHexColor(currentColors[base]);
            }

            return {
                fillColor: fillColor,
                weight: 1,
                opacity: 1,
                color: '#333',
                fillOpacity: fillOpacity
            };
        }

        // Funzione per creare il contenuto del popup quando si clicca su un comune
        function onEachFeature(feature, layer) {
            if (feature.properties && feature.properties.name) {
                const normalizedComuneNome = feature.properties.normalizedName;
                const base = getBaseForComune(normalizedComuneNome) || 'Non assegnata';
                const selectedDay = daySelector.value;
                const selectedRisk = riskSelector.value;

                let popupContent = `<b>Comune: ${feature.properties.name}</b><br>Base di Appartenenza: ${base}<br>`;

                if (selectedDay === 'riassunto') {
                    const allRiskTypes = Object.keys(riskColorsData).filter(key => key !== 'dataCreazione');
                    popupContent += `Criticità (Oggi/Domani):<br>`;
                    allRiskTypes.forEach(riskType => {
                        const colorToday = riskColorsData[riskType] && riskColorsData[riskType]['oggi'] ? (riskColorsData[riskType]['oggi'][base] || 'green') : 'green';
                        const colorTomorrow = riskColorsData[riskType] && riskColorsData[riskType]['domani'] ? (riskColorsData[riskType]['domani'][base] || 'green') : 'green';

                        // Mostra solo i rischi che non sono verdi (quindi che hanno una criticità)
                        if (colorToday.toLowerCase() !== 'green' || colorTomorrow.toLowerCase() !== 'green') {
                            popupContent += `- ${riskDisplayName[riskType] || riskType}: Oggi <span style="color:${getHexColor(colorToday)}">${colorToday.charAt(0).toUpperCase() + colorToday.slice(1)}</span>, Domani <span style="color:${getHexColor(colorTomorrow)}">${colorTomorrow.charAt(0).toUpperCase() + colorTomorrow.slice(1)}</span><br>`;
                        }
                    });
                     // Se non ci sono criticità da mostrare
                    if (popupContent.endsWith('Criticità (Oggi/Domani):<br>')) {
                        popupContent += `Nessuna criticità rilevante per Oggi/Domani.`;
                    }

                } else {
                    const currentColors = getColorsForCurrentSelection();
                    const riskColorName = currentColors[base] || 'N/A';
                    const riskDisplayNameText = riskDisplayName[selectedRisk] || selectedRisk;
                    popupContent += `Rischio "${riskDisplayNameText}": ${riskColorName.charAt(0).toUpperCase() + riskColorName.slice(1)}`;
                }
                layer.bindPopup(popupContent);
            }
        }


        // Funzione per aggiornare la legenda dinamica
        function updateLegend(colorsForSelectedView) {
            currentRiskLegend.innerHTML = '<h4>Legenda Rischio Corrente:</h4>';

            // Ordina le basi per un ordine consistente nella legenda
            const sortedBases = Object.keys(configurazioneCriticità).sort((a, b) => {
                // Ordine specifico per le basi (A1, A2, B, C, D, E1, E2)
                const order = ['A1', 'A2', 'B', 'C', 'D', 'E1', 'E2'];
                return order.indexOf(a) - order.indexOf(b);
            });

            // Aggiungi gli elementi della legenda per le basi che hanno un colore per la vista selezionata
            sortedBases.forEach(base => {
                const colorName = colorsForSelectedView[base];
                if (colorName) { // Mostra solo le bases che hanno un colore definito
                    const hexColor = getHexColor(colorName);

                    const legendItem = document.createElement('div');
                    legendItem.className = 'legend-item';

                    const colorBox = document.createElement('div');
                    colorBox.className = 'legend-color-box';
                    colorBox.style.backgroundColor = hexColor;

                    const text = document.createElement('span');
                    text.textContent = `Base ${base}: ${colorName.charAt(0).toUpperCase() + colorName.slice(1)}`;

                    legendItem.appendChild(colorBox);
                    legendItem.appendChild(text);
                    currentRiskLegend.appendChild(legendItem);
                }
            });

            // Aggiungi una voce di default per le aree non colorate/non mappate
            const defaultItem = document.createElement('div');
            defaultItem.className = 'legend-item';
            const defaultColorBox = document.createElement('div');
            defaultColorBox.className = 'legend-color-box';
            defaultColorBox.style.backgroundColor = '#ccc';
            const defaultText = document.createElement('span');
            defaultText.textContent = `Base Non Mappata / Nessun Rischio`;
            defaultItem.appendChild(defaultColorBox);
            defaultItem.appendChild(defaultText);
            currentRiskLegend.appendChild(defaultItem);
        }

        // Logica di Generazione del PDF
        savePdfButton.addEventListener('click', function () {
            console.log("Inizio generazione PDF...");

            const selectedDay = daySelector.value;
            const selectedRisk = riskSelector.value;
            const pdfSelectedRiskDisplayName = riskDisplayName[selectedRisk] || selectedRisk;
            const currentColors = getColorsForCurrentSelection();

            // Definisci gli stili specifici per il PDF (opacità piena)
            const pdfStyleComune = (feature) => {
                const normalizedComuneNome = feature.properties.normalizedName;
                const base = getBaseForComune(normalizedComuneNome);
                let fillColor = '#ccc'; // Default per il PDF

                if (base && currentColors[base]) {
                    fillColor = getHexColor(currentColors[base]);
                }

                return {
                    fillColor: fillColor,
                    weight: 1,
                    opacity: 1,
                    color: '#333',
                    fillOpacity: 1 // Opacità piena per la cattura del PDF
                };
            };

            // Applica temporaneamente gli stili PDF per la cattura dell'immagine
            if (geoJsonLayer) {
                geoJsonLayer.setStyle(pdfStyleComune);
            }

            // Forza il reflow (per assicurare che Leaflet abbia ridisegnato)
            leafletMap.getContainer().style.display;

            // Piccola attesa per il rendering della mappa con i nuovi stili
            setTimeout(function () {
                console.log("Chiamata leafletImage...");

                leafletImage(leafletMap, function (err, canvas) {
                    console.log("Callback di leafletImage eseguito.");

                    if (err) {
                        console.error("Errore in leafletImage:", err);
                        return;
                    }

                    const imgData = canvas.toDataURL('image/png');
                    const { jsPDF } = window.jspdf;
                    const pdf = new jsPDF('landscape'); // Formato orizzontale
                    const imgWidth = pdf.internal.pageSize.getWidth() - 20; // Larghezza immagine (con margini)
                    const imgHeight = (canvas.height * imgWidth) / canvas.width; // Altezza proporzionale

                    let currentY = 10; // Posizione Y iniziale per gli elementi

                    // Aggiungi Titolo
                    let titleText = `Bollettino Criticità - Giorno: ${daySelector.options[daySelector.selectedIndex].text}`;
                    if (selectedDay !== 'riassunto') {
                        titleText += ` - Rischio: ${pdfSelectedRiskDisplayName}`;
                    }
                    pdf.setFontSize(20);
                    pdf.text(titleText, 10, currentY);
                    currentY += 15;

                    // Aggiungi l'immagine della mappa
                    pdf.addImage(imgData, 'PNG', 10, currentY, imgWidth, imgHeight);
                    currentY += imgHeight + 10;

                    // Aggiungi il testo "Ultimo Aggiornamento"
                    pdf.setFontSize(10);
                    pdf.text(lastUpdatedElement.textContent, 10, currentY);
                    currentY += 10;

                    // Aggiungi Logo (in alto a destra)
                    const logoImg = document.getElementById('region-logo');
                    if (logoImg) {
                        const logoData = logoImg.src;
                        const logoPdfWidth = 40;
                        const logoPdfHeight = (logoImg.naturalHeight * logoPdfWidth) / logoImg.naturalWidth;
                        const pdfPageWidth = pdf.internal.pageSize.getWidth();
                        pdf.addImage(logoData, 'PNG', pdfPageWidth - logoPdfWidth - 10, 10, logoPdfWidth, logoPdfHeight);
                    }

                    // Aggiungi Legenda per il rischio specifico (in basso a destra)
                    let legendStartX = pdf.internal.pageSize.getWidth() - 80; // Posiziona la legenda a destra
                    let legendY = 20; // Inizio legenda in alto, dopo il logo

                    pdf.setFontSize(12);
                    pdf.text('Legenda:', legendStartX, legendY);
                    legendY += 5;

                    // Ottieni le basi ordinate che hanno colori per la vista corrente
                    const sortedBasesForLegend = Object.keys(configurazioneCriticità).filter(base => currentColors[base]).sort((a, b) => {
                        const order = ['A1', 'A2', 'B', 'C', 'D', 'E1', 'E2'];
                        return order.indexOf(a) - order.indexOf(b);
                    });

                    sortedBasesForLegend.forEach((base) => {
                        const colorName = currentColors[base];
                        const hexColor = getHexColor(colorName);
                        pdf.setFillColor(hexColor);
                        pdf.rect(legendStartX, legendY + 2, 5, 5, 'F'); // Quadro colore
                        pdf.setFontSize(10);
                        pdf.text(`Base ${base}: ${colorName.charAt(0).toUpperCase() + colorName.slice(1)}`, legendStartX + 8, legendY + 6);
                        legendY += 8;
                    });
                    // Aggiungi una voce di default per le aree non colorate
                    pdf.setFillColor('#ccc');
                    pdf.rect(legendStartX, legendY + 2, 5, 5, 'F');
                    pdf.setFontSize(10);
                    pdf.text('Base Non Mappata / Nessun Rischio', legendStartX + 8, legendY + 6);


                    pdf.save(`bollettino_criticità_${selectedDay}_${selectedDay !== 'riassunto' ? pdfSelectedRiskDisplayName.replace(/\s+/g, '_') + '_' : ''}${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.pdf`);

                    console.log("PDF generato e salvato.");

                    // Ripristina gli stili originali della mappa (per la visualizzazione a schermo)
                    if (geoJsonLayer) {
                        geoJsonLayer.setStyle(function (feature) {
                            return styleComune(feature, currentColors);
                        });
                    }
                });
            }, 1000); // Aumenta l'attesa a 1 secondo per il rendering
        });

        // Inizializza la mappa e i dati all'apertura della pagina
        initializeMap();

    </script>

</body>

</html>
